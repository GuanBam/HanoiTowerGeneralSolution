For Classic Hanoi, there's only one way to solve the problem, like the below pseudocode shows

With Pegs a,b,c
Hanoi(n,a,b,c):
    if n==1:
        c.push(a.pop())
    else:
    Hanoi(n-1,a,c,b)
    Hanoi(n,a,b,c)
    Hanoi(n-1,b,a,c)

For three pegs,
The least moves will increase with the disks number, M(n) = 2^n - 1
Disk:   1       2       3       4       5       6       7       8       9       10
Move:   1       3       7       15      31      63      127     255     511     1023

For Four Pegs, we can move part of disks(k) to one buffer peg first, move the remained disks(n-k) to the final peg,
then move the (k) disks to the final peg. The total move will be 2*move(k) + move(n-k)
As an example, for 5 disks with 4 pegs, we can consider.
  k :   1       2       3       4       5
left:   4       3       2       1       0
move:   16      13      17      31      31

According to Frame-Stewart Algorithm
Step 1: Move K disks from peg A to B or C as a cache peg.
Step 2: Move left(n-k) from peg A to D without passing by the cache peg.
Step 3: Move K disks from cache peg to peg D.

The simplified recurrence formula will be:
F(n,m) = min(2F(k,m) + F(n-k,m-1))    (k= [1,n])

So, here the main problem is figure out what is the k for each step.
Using the equation I'm able to get All K for each step.

Here's the new loop
1. Check current Number of Disk and Number of Peg F(N,M)
    If Meet Condition:
        Run Classic Solution
    Else:
        find the best K from the table
        If K existed:
            turn it into two parts, one is 2*F(K,M) one is F(N-K,M-1)
            Move K from src to buff
            Move N-K from src to dst
            Move K from buff to dst